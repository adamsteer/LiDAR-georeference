"""
A module which handles uncertainty propagation from instrumentation to points.

This module is generally called in :py:class:georefencer, but can be used as a stand-alone module to estimate the impact of various intrument parameters on output data uncertainties.

:py:class:createJacobians uses :py:module:SymPy to generate and write out the partial derivatives required to perform variance-covariance propagation through the LiDAR georefereincing equation. This needs to be run once for every instrument configuration, results are stored in a configuration file which is referred to in the georeferencing process.

:py:class:computeUncertainties uses the configuration file generated by :py:class:createJacobians to produce X, Y and Up uncertainties for each LiDAR point at processing time. These are stored as extra dimensions in the desired output file.

#just getting started

Adam Steer
2017
"""
#collect dependencies
import numpy as np
from sympy import *


def createJacobians():
    """
    Generate some code for us. What we want to do here is some symbolic math to generate partial derivaties for each componenent of the
    lIDAR equation. It needs to be run once per sensor...

    Input is a list of symbols

    Output is ... not sure. Matrices useable in computeUncertainties. Sympy reading required.    
    """

    return(jacobians)

def computeUncertanties(trajectory, lidarpoints, uncertaintyparams, jacobians)
    """
    this was originally wrapped in a for loop, processing one point at a time.
    Done to avoid making new len(lidar) arrays to hold fixed uncertainties (eg boresight misalignment, LiDAR range)
    
    Likely needs to stay in a for loop now, but done in parallel with georeferencing.

    trajectory needs to be pre-interpolated to match LIDAR observation frequency
    """

    #create a diagonal matrix of uncertainties, following Schaer et al (2010)
    theerrors = diag([eGPSX, eGPSY, eGPSZ, eRoll, ePitch, eYaw, eBSx, eBSy, eBSz, eR, eA, eLAx, eLAy, eLAz]).^2;
    
    #put it all together in the error model...
    pointUncertaintyXYZ = jacobians.theerrors.np.transpose(jacobians);

    #return a per-point XYZ uncertainty
    return pointUncertaintyXYZ

